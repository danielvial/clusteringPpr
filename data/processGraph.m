% Processes graph from .txt file to .mat file for our code
%
% Input: graph - string of graph name; uOrD - 'u' or 'd' to denote
% undirected or directed graph (assumes directed if no input)
%
% Assumes existence of graph-r.txt, which is relabeled version of original
% graph (from SNAP) generated by relabelSnap.py (see README)
%
% Creates .mat file containing graph object used in our code, which
% contains number nodes, number edges, out-degrees, in-degrees,
% out-neighbor sets, and in-neighbor sets (see README for details)
%  
function processGraph(graph,uOrD)

    if nargin == 1
        uOrD = 'd';
    end
    
    % will use David Gleich's gaimc (Graph Algorithms In Matlab Code)
    % package to ensure strong-connectedness; see README
    addpath gaimc;
    
    disp('loading raw data');
    E = importdata([graph '-r.txt'])+1; % +1 for MATLAB indexing
    n = max(E(:)); % number of nodes = highest node index
    
    disp('finding largest scc');
    A = sparse(E(:,1),E(:,2),1,n,n); % convert edge-list to adjacency
    if uOrD == 'u'
        A = A+A'; % if undirected, edge-list saves each edge only once, so symmetrize adjacency
    end
    scc = scomponents(A); % strongly-connected components (SCC)
    maxSccInd = mode(scc); % largest SCC
    maxScc = find(scc==maxSccInd); % nodes belonging to largest SCC
    A = A(maxScc,maxScc); % sub-graph of largest SCC
    A = A-diag(diag(A)); % remove self-loops (if any)
    n = length(A); m = nnz(A); % number nodes/edges in largest SCC
    Dout = sum(A,2); Din = sum(A,1)'; % out- and in-degrees in largest SCC
    
    disp('constructing Nout');
    [Eout,~] = find(A'); % list of all out-neighbors
    Nout = cell(n,1); % Nout{i} will contain out-neighbors of node i
    last = 0; % iterator
    for i=1:n
        % node i has Dout(i) out-neighbors, so save the next Dout(i)
        % entries from the list of all out-neighbors to Nout{i}
        Nout{i} = Eout(last+1:last+Dout(i));
        last = last+Dout(i);
    end
    
    disp('constructing Nin');
    [Ein,~] = find(A); % list of all in-neighbors
    Nin = cell(n,1); % Nin{i} will contain in-neighbors of node i
    last = 0; % iterator
    for i=1:n
        % node i has Din(i) in-neighbors, so save the next Din(i)
        % entries from the list of all in-neighbors to Nin{i}
        Nin{i} = Ein(last+1:last+Din(i));
        last = last+Din(i);
    end
    
    disp('verifying computation');
    % reconstruct adjacency matrix from neighbor lists to ensure
    % no mistakes in code above
    E = zeros(m,2); last = 0;
    for i=1:n
        E(last+1:last+Dout(i),1) = i;
        E(last+1:last+Dout(i),2) = Nout{i};
        last = last+Dout(i);
    end
    Atest = sparse(E(:,1),E(:,2),1,n,n);
    if ~isequal(Atest,A)
        disp('construction error');
    end
    if length(unique(scomponents(Atest))) > 1
        disp('scc error');
    end
    
    disp('saving cleaned data');
    % save graph object as described in README
    G.n = n; G.m = m; G.Dout = Dout; G.Din = Din; G.Nout = Nout; G.Nin = Nin;
    save([graph '.mat'],'G');
    
end


